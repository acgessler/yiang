<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>SFML - Simple and Fast Multimedia Library</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="tabs.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div id="logo">
            <img src="./logo.jpg" width="770" height="200" title="SFML home" alt="SFML logo" />
        </div>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="namespaces.htm"><span>Namespaces</span></a></li>
    <li><a href="classes.htm"><span>Classes</span></a></li>
    <li><a href="files.htm"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.htm"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.htm"><span>Namespace&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>sf Namespace Reference</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1AudioResource.htm">AudioResource</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class for every class that owns a device-dependant resource -- allow them to initialize / shutdown even when the audio context is not created.  <a href="classsf_1_1AudioResource.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Listener.htm">Listener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Listener.htm" title="Listener is a global interface for defining the audio listener properties ; the audio...">Listener</a> is a global interface for defining the audio listener properties ; the audio listener is the point in the scene from where all the sounds are heard.  <a href="classsf_1_1Listener.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Music.htm">Music</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Music.htm" title="Music defines a big sound played using streaming, so usually what we call a music...">Music</a> defines a big sound played using streaming, so usually what we call a music :).  <a href="classsf_1_1Music.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Sound.htm">Sound</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Sound.htm" title="Sound defines the properties of a sound such as position, volume, pitch, etc.">Sound</a> defines the properties of a sound such as position, volume, pitch, etc.  <a href="classsf_1_1Sound.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SoundBuffer.htm">SoundBuffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1SoundBuffer.htm" title="SoundBuffer is the low-level for loading and manipulating sound buffers.">SoundBuffer</a> is the low-level for loading and manipulating sound buffers.  <a href="classsf_1_1SoundBuffer.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SoundBufferRecorder.htm">SoundBufferRecorder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialized <a class="el" href="classsf_1_1SoundRecorder.htm" title="SoundRecorder is an interface for capturing sound data, it is meant to be used as...">SoundRecorder</a> which saves the captured audio data into a sound buffer.  <a href="classsf_1_1SoundBufferRecorder.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SoundRecorder.htm">SoundRecorder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1SoundRecorder.htm" title="SoundRecorder is an interface for capturing sound data, it is meant to be used as...">SoundRecorder</a> is an interface for capturing sound data, it is meant to be used as a base class.  <a href="classsf_1_1SoundRecorder.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SoundStream.htm">SoundStream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1SoundStream.htm" title="SoundStream is a streamed sound, ie samples are acquired while the sound is playing...">SoundStream</a> is a streamed sound, ie samples are acquired while the sound is playing.  <a href="classsf_1_1SoundStream.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Color.htm">Color</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Color.htm" title="Color is an utility class for manipulating 32-bits RGBA colors.">Color</a> is an utility class for manipulating 32-bits RGBA colors.  <a href="classsf_1_1Color.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Drawable.htm">Drawable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class for every object that can be drawn into a render window.  <a href="classsf_1_1Drawable.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Font.htm">Font</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Font.htm" title="Font is the low-level class for loading and manipulating character fonts.">Font</a> is the low-level class for loading and manipulating character fonts.  <a href="classsf_1_1Font.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Glyph.htm">Glyph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure describing a glyph (a visual character).  <a href="classsf_1_1Glyph.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Image.htm">Image</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Image.htm" title="Image is the low-level class for loading and manipulating images.">Image</a> is the low-level class for loading and manipulating images.  <a href="classsf_1_1Image.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Matrix3.htm">Matrix3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility class to manipulate 3x3 matrices representing 2D transformations.  <a href="classsf_1_1Matrix3.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1PostFX.htm">PostFX</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1PostFX.htm" title="PostFX is used to apply a post effect to a window.">PostFX</a> is used to apply a post effect to a window.  <a href="classsf_1_1PostFX.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Rect.htm">Rect</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Rect.htm" title="Rect is an utility class for manipulating rectangles.">Rect</a> is an utility class for manipulating rectangles.  <a href="classsf_1_1Rect.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm">RenderTarget</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for all render targets (window, image, .  <a href="classsf_1_1RenderTarget.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderWindow.htm">RenderWindow</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple wrapper for <a class="el" href="classsf_1_1Window.htm" title="Window is a rendering window ; it can create a new window or connect to an existing...">sf::Window</a> that allows easy 2D rendering.  <a href="classsf_1_1RenderWindow.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Shape.htm">Shape</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Shape.htm" title="Shape defines a drawable convex shape ; it also defines helper functions to draw...">Shape</a> defines a drawable convex shape ; it also defines helper functions to draw simple shapes like lines, rectangles, circles, etc.  <a href="classsf_1_1Shape.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Sprite.htm">Sprite</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Sprite.htm" title="Sprite defines a sprite : texture, transformations, color, and draw on screen.">Sprite</a> defines a sprite : texture, transformations, color, and draw on screen.  <a href="classsf_1_1Sprite.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1String.htm">String</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1String.htm" title="String defines a graphical 2D text, that can be drawn on screen.">String</a> defines a graphical 2D text, that can be drawn on screen.  <a href="classsf_1_1String.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1View.htm">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class defines a view (position, size, etc.  <a href="classsf_1_1View.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Ftp.htm">Ftp</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides methods for manipulating the FTP protocol (described in RFC 959).  <a href="classsf_1_1Ftp.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Http.htm">Http</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides methods for manipulating the HTTP protocol (described in RFC 1945).  <a href="classsf_1_1Http.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1IPAddress.htm">IPAddress</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1IPAddress.htm" title="IPAddress provides easy manipulation of IP v4 addresses.">IPAddress</a> provides easy manipulation of IP v4 addresses.  <a href="classsf_1_1IPAddress.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Packet.htm">Packet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Packet.htm" title="Packet wraps data to send / to receive through the network.">Packet</a> wraps data to send / to receive through the network.  <a href="classsf_1_1Packet.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Selector.htm">Selector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Selector.htm" title="Selector allow reading from multiple sockets without blocking.">Selector</a> allow reading from multiple sockets without blocking.  <a href="classsf_1_1Selector.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SelectorBase.htm">SelectorBase</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Private base class for selectors.  <a href="classsf_1_1SelectorBase.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SocketTCP.htm">SocketTCP</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1SocketTCP.htm" title="SocketTCP wraps a socket using TCP protocol to send data safely (but a bit slower)...">SocketTCP</a> wraps a socket using TCP protocol to send data safely (but a bit slower).  <a href="classsf_1_1SocketTCP.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SocketUDP.htm">SocketUDP</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1SocketUDP.htm" title="SocketUDP wraps a socket using UDP protocol to send data fastly (but with less safety)...">SocketUDP</a> wraps a socket using UDP protocol to send data fastly (but with less safety).  <a href="classsf_1_1SocketUDP.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SocketHelper.htm">SocketHelper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class defines helper functions to do all the non-portable socket stuff.  <a href="classsf_1_1SocketHelper.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Clock.htm">Clock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Clock.htm" title="Clock is an utility class for manipulating time.">Clock</a> is an utility class for manipulating time.  <a href="classsf_1_1Clock.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Lock.htm">Lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Lock.htm" title="Lock is an exception-safe automatic wrapper for locking and unlocking mutexes.">Lock</a> is an exception-safe automatic wrapper for locking and unlocking mutexes.  <a href="classsf_1_1Lock.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsf_1_1NonCopyable.htm">NonCopyable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility base class to easily declare non-copyable classes.  <a href="structsf_1_1NonCopyable.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Randomizer.htm">Randomizer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Randomizer.htm" title="Randomizer is an utility class for generating pseudo-random numbers.">Randomizer</a> is an utility class for generating pseudo-random numbers.  <a href="classsf_1_1Randomizer.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Resource.htm">Resource</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for every resource that needs to notify dependent classes about its destruction.  <a href="classsf_1_1Resource.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1ResourcePtr.htm">ResourcePtr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safe pointer to a T resource (inheriting from sf::Resource&lt;T&gt;), its pointer is automatically reseted when the resource is destroyed.  <a href="classsf_1_1ResourcePtr.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Unicode.htm">Unicode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides utility functions to convert from and to any unicode and ASCII encoding.  <a href="classsf_1_1Unicode.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Vector2.htm" title="Vector2 is an utility class for manipulating 2 dimensional vectors.">Vector2</a> is an utility class for manipulating 2 dimensional vectors.  <a href="classsf_1_1Vector2.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Vector3.htm" title="Vector3 is an utility class for manipulating 3 dimensional vectors.">Vector3</a> is an utility class for manipulating 3 dimensional vectors.  <a href="classsf_1_1Vector3.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Mutex.htm">Mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Mutex.htm" title="Mutex defines a mutex (MUTual EXclusion) object, that allows a thread to lock critical...">Mutex</a> defines a mutex (MUTual EXclusion) object, that allows a thread to lock critical instructions to avoid simultaneous access with other threads.  <a href="classsf_1_1Mutex.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Thread.htm">Thread</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Thread.htm" title="Thread defines an easy way to manipulate a thread.">Thread</a> defines an easy way to manipulate a thread.  <a href="classsf_1_1Thread.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Context.htm">Context</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class wrapping an OpenGL context.  <a href="classsf_1_1Context.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Event.htm">Event</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Event.htm" title="Event defines a system event and its parameters.">Event</a> defines a system event and its parameters.  <a href="classsf_1_1Event.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Input.htm">Input</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Input.htm" title="Input handles real-time input from keyboard and mouse.">Input</a> handles real-time input from keyboard and mouse.  <a href="classsf_1_1Input.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1VideoMode.htm">VideoMode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1VideoMode.htm" title="VideoMode defines a video mode (width, height, bpp, frequency) and provides static...">VideoMode</a> defines a video mode (width, height, bpp, frequency) and provides static functions for getting modes supported by the display device.  <a href="classsf_1_1VideoMode.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm">Window</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsf_1_1Window.htm" title="Window is a rendering window ; it can create a new window or connect to an existing...">Window</a> is a rendering window ; it can create a new window or connect to an existing one.  <a href="classsf_1_1Window.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowListener.htm">WindowListener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for classes that want to receive events from a window (for internal use only).  <a href="classsf_1_1WindowListener.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsf_1_1WindowSettings.htm">WindowSettings</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure defining the creation settings of windows.  <a href="structsf_1_1WindowSettings.htm#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf_1_1Blend.htm">Blend</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerate the blending modes for drawable objects. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf_1_1Joy.htm">Joy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Definition of joystick axis for joystick events. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf_1_1Key.htm">Key</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Definition of key codes for keyboard events. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf_1_1Mouse.htm">Mouse</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Definition of button codes for mouse events. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf_1_1Socket.htm">Socket</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf_1_1Style.htm">Style</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration of window creation styles. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ae67411782674934f78d55fa3af18403"></a><!-- doxytag: member="sf::IntRect" ref="ae67411782674934f78d55fa3af18403" args="" -->
typedef <a class="el" href="classsf_1_1Rect.htm">Rect</a>&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf.htm#ae67411782674934f78d55fa3af18403">IntRect</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed4e58f586b2eed2621c0365d0b7554e"></a><!-- doxytag: member="sf::FloatRect" ref="ed4e58f586b2eed2621c0365d0b7554e" args="" -->
typedef <a class="el" href="classsf_1_1Rect.htm">Rect</a>&lt; float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf.htm#ed4e58f586b2eed2621c0365d0b7554e">FloatRect</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="13c701ddf3cd92aaf654959b7332e31b"></a><!-- doxytag: member="sf::SelectorUDP" ref="13c701ddf3cd92aaf654959b7332e31b" args="" -->
typedef <a class="el" href="classsf_1_1Selector.htm">Selector</a>&lt; <a class="el" href="classsf_1_1SocketUDP.htm">SocketUDP</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf.htm#13c701ddf3cd92aaf654959b7332e31b">SelectorUDP</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="84a3519e6e7dbda0ccd64ba63304e48a"></a><!-- doxytag: member="sf::SelectorTCP" ref="84a3519e6e7dbda0ccd64ba63304e48a" args="" -->
typedef <a class="el" href="classsf_1_1Selector.htm">Selector</a>&lt; <a class="el" href="classsf_1_1SocketTCP.htm">SocketTCP</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf.htm#84a3519e6e7dbda0ccd64ba63304e48a">SelectorTCP</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce09dd1447d74c6e9ba56ae874c094e1"></a><!-- doxytag: member="sf::Vector2i" ref="ce09dd1447d74c6e9ba56ae874c094e1" args="" -->
typedef <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf.htm#ce09dd1447d74c6e9ba56ae874c094e1">Vector2i</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf03098c2577b869e2fa6836cc48f1a0"></a><!-- doxytag: member="sf::Vector2f" ref="cf03098c2577b869e2fa6836cc48f1a0" args="" -->
typedef <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf.htm#cf03098c2577b869e2fa6836cc48f1a0">Vector2f</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d066a8774efaf7b623df8909ba219dc7"></a><!-- doxytag: member="sf::Vector3i" ref="d066a8774efaf7b623df8909ba219dc7" args="" -->
typedef <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf.htm#d066a8774efaf7b623df8909ba219dc7">Vector3i</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f97357d7d32e7d6a700d03be2f3b4811"></a><!-- doxytag: member="sf::Vector3f" ref="f97357d7d32e7d6a700d03be2f3b4811" args="" -->
typedef <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf.htm#f97357d7d32e7d6a700d03be2f3b4811">Vector3f</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SFML_API <a class="el" href="classsf_1_1Color.htm">Color</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf.htm#50ca5b482d1bed9710ecedfab8f3aa71">operator+</a> (const <a class="el" href="classsf_1_1Color.htm">Color</a> &amp;Color1, const <a class="el" href="classsf_1_1Color.htm">Color</a> &amp;Color2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator + overload to add two colors.  <a href="#50ca5b482d1bed9710ecedfab8f3aa71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SFML_API <a class="el" href="classsf_1_1Color.htm">Color</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf.htm#22072379b0571262018fd6f4c86d4e97">operator *</a> (const <a class="el" href="classsf_1_1Color.htm">Color</a> &amp;Color1, const <a class="el" href="classsf_1_1Color.htm">Color</a> &amp;Color2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator * overload to modulate two colors.  <a href="#22072379b0571262018fd6f4c86d4e97"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SFML_API std::istream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf.htm#cc2f75d5067454f82d05b194ecad3ad1">operator&gt;&gt;</a> (std::istream &amp;Stream, <a class="el" href="classsf_1_1IPAddress.htm">IPAddress</a> &amp;Address)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator &gt;&gt; overload to extract an address from an input stream.  <a href="#cc2f75d5067454f82d05b194ecad3ad1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SFML_API std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf.htm#664bd54831f1d70588ae9da837be84f9">operator&lt;&lt;</a> (std::ostream &amp;Stream, const <a class="el" href="classsf_1_1IPAddress.htm">IPAddress</a> &amp;Address)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator &lt;&lt; overload to print an address to an output stream.  <a href="#664bd54831f1d70588ae9da837be84f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void SFML_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesf.htm#bf3b28a7f7637d7babad2756db57e44d">Sleep</a> (float Duration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the current thread sleep for a given time.  <a href="#bf3b28a7f7637d7babad2756db57e44d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#29068b8765da7da08c8d14ee7ea172ba">operator-</a> (const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator - overload ; returns the opposite of a vector.  <a href="#29068b8765da7da08c8d14ee7ea172ba"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#71e0dfa420275963771644b8f6b44796">operator+=</a> (<a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V1, const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator += overload ; add two vectors and assign to the first op.  <a href="#71e0dfa420275963771644b8f6b44796"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#78dfec22ce1dcce6407d11a83bf57734">operator-=</a> (<a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V1, const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator -= overload ; subtract two vectors and assign to the first op.  <a href="#78dfec22ce1dcce6407d11a83bf57734"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#0f2eb581a681f6deb581e094fdb53a9e">operator+</a> (const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V1, const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator + overload ; adds two vectors.  <a href="#0f2eb581a681f6deb581e094fdb53a9e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#e3fd4f6a0efdc46a0de2051faf1add60">operator-</a> (const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V1, const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator - overload ; subtracts two vectors.  <a href="#e3fd4f6a0efdc46a0de2051faf1add60"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#d4cf928e5b6866405aabb7052310ea62">operator *</a> (const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V, T X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator * overload ; multiply a vector by a scalar value.  <a href="#d4cf928e5b6866405aabb7052310ea62"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#3933ff150bdfb735773dbbb608f3f797">operator *</a> (T X, const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator * overload ; multiply a scalar value by a vector.  <a href="#3933ff150bdfb735773dbbb608f3f797"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#da51460bf4cef8c1c958cae5c0eeb76f">operator *=</a> (<a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V, T X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator *= overload ; multiply-assign a vector by a scalar value.  <a href="#da51460bf4cef8c1c958cae5c0eeb76f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#4d79f25d6c4b1601438becfff7256627">operator/</a> (const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V, T X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator / overload ; divide a vector by a scalar value.  <a href="#4d79f25d6c4b1601438becfff7256627"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#7d5a1bbf217894f98676c8cd4c57a8d1">operator/=</a> (<a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V, T X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator /= overload ; divide-assign a vector by a scalar value.  <a href="#7d5a1bbf217894f98676c8cd4c57a8d1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#eb2e9506aa20c13b065592724eafa1d7">operator==</a> (const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V1, const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator == overload ; compares the equality of two vectors.  <a href="#eb2e9506aa20c13b065592724eafa1d7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#d34adb0b3cd1ff8176cd14eab6ffd7db">operator!=</a> (const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V1, const <a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt; T &gt; &amp;V2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator != overload ; compares the difference of two vectors.  <a href="#d34adb0b3cd1ff8176cd14eab6ffd7db"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#d4c71d97c45a59ad8dd98d3e14783777">operator-</a> (const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator - overload ; returns the opposite of a vector.  <a href="#d4c71d97c45a59ad8dd98d3e14783777"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#ef4c082ad59153965b9488b658242c3e">operator+=</a> (<a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V1, const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator += overload ; add two vectors and assign to the first op.  <a href="#ef4c082ad59153965b9488b658242c3e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#3dc1e74397a094898d817414a5bf53d5">operator-=</a> (<a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V1, const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator -= overload ; subtract two vectors and assign to the first op.  <a href="#3dc1e74397a094898d817414a5bf53d5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#e65378670dbb9a0584525733be74b7ce">operator+</a> (const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V1, const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator + overload ; adds two vectors.  <a href="#e65378670dbb9a0584525733be74b7ce"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#8140415090446c9dc32557130a6fc615">operator-</a> (const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V1, const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator - overload ; subtracts two vectors.  <a href="#8140415090446c9dc32557130a6fc615"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#ecf4c372161c86d48bbdefbe8fa2bedd">operator *</a> (const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V, T X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator * overload ; multiply a vector by a scalar value.  <a href="#ecf4c372161c86d48bbdefbe8fa2bedd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#79a78a8d7ffad52962430e966f8ffac2">operator *</a> (T X, const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator * overload ; multiply a scalar value by a vector.  <a href="#79a78a8d7ffad52962430e966f8ffac2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#a8157f42e0a980b6cd3f030bfdded422">operator *=</a> (<a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V, T X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator *= overload ; multiply-assign a vector by a scalar value.  <a href="#a8157f42e0a980b6cd3f030bfdded422"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#25bfb0f930a61146fdd82ceb6c3566ae">operator/</a> (const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V, T X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator / overload ; divide a vector by a scalar value.  <a href="#25bfb0f930a61146fdd82ceb6c3566ae"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#29b29d4b0d643cfaa38206695c4518ba">operator/=</a> (<a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V, T X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator /= overload ; divide-assign a vector by a scalar value.  <a href="#29b29d4b0d643cfaa38206695c4518ba"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#2d7edce0db1b576722d9e364c7d08ef9">operator==</a> (const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V1, const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator == overload ; compares the equality of two vectors.  <a href="#2d7edce0db1b576722d9e364c7d08ef9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesf.htm#ef3bad9356e5bcfed2c445aadfdabd55">operator!=</a> (const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V1, const <a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt; T &gt; &amp;V2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator != overload ; compares the difference of two vectors.  <a href="#ef3bad9356e5bcfed2c445aadfdabd55"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="79a78a8d7ffad52962430e966f8ffac2"></a><!-- doxytag: member="sf::operator *" ref="79a78a8d7ffad52962430e966f8ffac2" args="(T X, const Vector3&lt; T &gt; &amp;V)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt;T&gt; sf::operator *           </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator * overload ; multiply a scalar value by a vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>: Scalar value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>: Vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>X * V </dd></dl>

</div>
</div><p>
<a class="anchor" name="ecf4c372161c86d48bbdefbe8fa2bedd"></a><!-- doxytag: member="sf::operator *" ref="ecf4c372161c86d48bbdefbe8fa2bedd" args="(const Vector3&lt; T &gt; &amp;V, T X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt;T&gt; sf::operator *           </td>
          <td>(</td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator * overload ; multiply a vector by a scalar value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>: Vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>: Scalar value</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V * X </dd></dl>

</div>
</div><p>
<a class="anchor" name="3933ff150bdfb735773dbbb608f3f797"></a><!-- doxytag: member="sf::operator *" ref="3933ff150bdfb735773dbbb608f3f797" args="(T X, const Vector2&lt; T &gt; &amp;V)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt;T&gt; sf::operator *           </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator * overload ; multiply a scalar value by a vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>: Scalar value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>: Vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>X * V </dd></dl>

</div>
</div><p>
<a class="anchor" name="d4cf928e5b6866405aabb7052310ea62"></a><!-- doxytag: member="sf::operator *" ref="d4cf928e5b6866405aabb7052310ea62" args="(const Vector2&lt; T &gt; &amp;V, T X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt;T&gt; sf::operator *           </td>
          <td>(</td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator * overload ; multiply a vector by a scalar value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>: Vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>: Scalar value</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V * X </dd></dl>

</div>
</div><p>
<a class="anchor" name="22072379b0571262018fd6f4c86d4e97"></a><!-- doxytag: member="sf::operator *" ref="22072379b0571262018fd6f4c86d4e97" args="(const Color &amp;Color1, const Color &amp;Color2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SFML_API <a class="el" href="classsf_1_1Color.htm">Color</a> sf::operator *           </td>
          <td>(</td>
          <td class="paramtype">const Color &amp;&nbsp;</td>
          <td class="paramname"> <em>Color1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Color &amp;&nbsp;</td>
          <td class="paramname"> <em>Color2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator * overload to modulate two colors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Color1</em>&nbsp;</td><td>: First color </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Color2</em>&nbsp;</td><td>: Second color</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Component-wise multiplication of the two colors </dd></dl>

</div>
</div><p>
<a class="anchor" name="a8157f42e0a980b6cd3f030bfdded422"></a><!-- doxytag: member="sf::operator *=" ref="a8157f42e0a980b6cd3f030bfdded422" args="(Vector3&lt; T &gt; &amp;V, T X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt;T&gt;&amp; sf::operator *=           </td>
          <td>(</td>
          <td class="paramtype">Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator *= overload ; multiply-assign a vector by a scalar value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>: Vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>: Scalar value</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V * X </dd></dl>

</div>
</div><p>
<a class="anchor" name="da51460bf4cef8c1c958cae5c0eeb76f"></a><!-- doxytag: member="sf::operator *=" ref="da51460bf4cef8c1c958cae5c0eeb76f" args="(Vector2&lt; T &gt; &amp;V, T X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt;T&gt;&amp; sf::operator *=           </td>
          <td>(</td>
          <td class="paramtype">Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator *= overload ; multiply-assign a vector by a scalar value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>: Vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>: Scalar value</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V * X </dd></dl>

</div>
</div><p>
<a class="anchor" name="ef3bad9356e5bcfed2c445aadfdabd55"></a><!-- doxytag: member="sf::operator!=" ref="ef3bad9356e5bcfed2c445aadfdabd55" args="(const Vector3&lt; T &gt; &amp;V1, const Vector3&lt; T &gt; &amp;V2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sf::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator != overload ; compares the difference of two vectors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>: First vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>: Second vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if V1 is different than V2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="d34adb0b3cd1ff8176cd14eab6ffd7db"></a><!-- doxytag: member="sf::operator!=" ref="d34adb0b3cd1ff8176cd14eab6ffd7db" args="(const Vector2&lt; T &gt; &amp;V1, const Vector2&lt; T &gt; &amp;V2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sf::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator != overload ; compares the difference of two vectors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>: First vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>: Second vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if V1 is different than V2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="e65378670dbb9a0584525733be74b7ce"></a><!-- doxytag: member="sf::operator+" ref="e65378670dbb9a0584525733be74b7ce" args="(const Vector3&lt; T &gt; &amp;V1, const Vector3&lt; T &gt; &amp;V2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt;T&gt; sf::operator+           </td>
          <td>(</td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator + overload ; adds two vectors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>: First vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>: Second vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V1 + V2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="0f2eb581a681f6deb581e094fdb53a9e"></a><!-- doxytag: member="sf::operator+" ref="0f2eb581a681f6deb581e094fdb53a9e" args="(const Vector2&lt; T &gt; &amp;V1, const Vector2&lt; T &gt; &amp;V2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt;T&gt; sf::operator+           </td>
          <td>(</td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator + overload ; adds two vectors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>: First vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>: Second vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V1 + V2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="50ca5b482d1bed9710ecedfab8f3aa71"></a><!-- doxytag: member="sf::operator+" ref="50ca5b482d1bed9710ecedfab8f3aa71" args="(const Color &amp;Color1, const Color &amp;Color2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SFML_API <a class="el" href="classsf_1_1Color.htm">Color</a> sf::operator+           </td>
          <td>(</td>
          <td class="paramtype">const Color &amp;&nbsp;</td>
          <td class="paramname"> <em>Color1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Color &amp;&nbsp;</td>
          <td class="paramname"> <em>Color2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator + overload to add two colors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Color1</em>&nbsp;</td><td>: First color </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Color2</em>&nbsp;</td><td>: Second color</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Component-wise saturated addition of the two colors </dd></dl>

</div>
</div><p>
<a class="anchor" name="ef4c082ad59153965b9488b658242c3e"></a><!-- doxytag: member="sf::operator+=" ref="ef4c082ad59153965b9488b658242c3e" args="(Vector3&lt; T &gt; &amp;V1, const Vector3&lt; T &gt; &amp;V2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt;T&gt;&amp; sf::operator+=           </td>
          <td>(</td>
          <td class="paramtype">Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator += overload ; add two vectors and assign to the first op. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>: First vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>: Second vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V1 + V2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="71e0dfa420275963771644b8f6b44796"></a><!-- doxytag: member="sf::operator+=" ref="71e0dfa420275963771644b8f6b44796" args="(Vector2&lt; T &gt; &amp;V1, const Vector2&lt; T &gt; &amp;V2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt;T&gt;&amp; sf::operator+=           </td>
          <td>(</td>
          <td class="paramtype">Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator += overload ; add two vectors and assign to the first op. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>: First vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>: Second vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V1 + V2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="8140415090446c9dc32557130a6fc615"></a><!-- doxytag: member="sf::operator-" ref="8140415090446c9dc32557130a6fc615" args="(const Vector3&lt; T &gt; &amp;V1, const Vector3&lt; T &gt; &amp;V2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt;T&gt; sf::operator-           </td>
          <td>(</td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator - overload ; subtracts two vectors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>: First vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>: Second vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V1 - V2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="d4c71d97c45a59ad8dd98d3e14783777"></a><!-- doxytag: member="sf::operator-" ref="d4c71d97c45a59ad8dd98d3e14783777" args="(const Vector3&lt; T &gt; &amp;V)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt;T&gt; sf::operator-           </td>
          <td>(</td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator - overload ; returns the opposite of a vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>: Vector to negate</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-V </dd></dl>

</div>
</div><p>
<a class="anchor" name="e3fd4f6a0efdc46a0de2051faf1add60"></a><!-- doxytag: member="sf::operator-" ref="e3fd4f6a0efdc46a0de2051faf1add60" args="(const Vector2&lt; T &gt; &amp;V1, const Vector2&lt; T &gt; &amp;V2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt;T&gt; sf::operator-           </td>
          <td>(</td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator - overload ; subtracts two vectors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>: First vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>: Second vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V1 - V2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="29068b8765da7da08c8d14ee7ea172ba"></a><!-- doxytag: member="sf::operator-" ref="29068b8765da7da08c8d14ee7ea172ba" args="(const Vector2&lt; T &gt; &amp;V)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt;T&gt; sf::operator-           </td>
          <td>(</td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator - overload ; returns the opposite of a vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>: Vector to negate</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-V </dd></dl>

</div>
</div><p>
<a class="anchor" name="3dc1e74397a094898d817414a5bf53d5"></a><!-- doxytag: member="sf::operator-=" ref="3dc1e74397a094898d817414a5bf53d5" args="(Vector3&lt; T &gt; &amp;V1, const Vector3&lt; T &gt; &amp;V2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt;T&gt;&amp; sf::operator-=           </td>
          <td>(</td>
          <td class="paramtype">Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator -= overload ; subtract two vectors and assign to the first op. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>: First vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>: Second vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V1 - V2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="78dfec22ce1dcce6407d11a83bf57734"></a><!-- doxytag: member="sf::operator-=" ref="78dfec22ce1dcce6407d11a83bf57734" args="(Vector2&lt; T &gt; &amp;V1, const Vector2&lt; T &gt; &amp;V2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt;T&gt;&amp; sf::operator-=           </td>
          <td>(</td>
          <td class="paramtype">Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator -= overload ; subtract two vectors and assign to the first op. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>: First vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>: Second vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V1 - V2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="25bfb0f930a61146fdd82ceb6c3566ae"></a><!-- doxytag: member="sf::operator/" ref="25bfb0f930a61146fdd82ceb6c3566ae" args="(const Vector3&lt; T &gt; &amp;V, T X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt;T&gt; sf::operator/           </td>
          <td>(</td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator / overload ; divide a vector by a scalar value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>: Vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>: Scalar value</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V / X </dd></dl>

</div>
</div><p>
<a class="anchor" name="4d79f25d6c4b1601438becfff7256627"></a><!-- doxytag: member="sf::operator/" ref="4d79f25d6c4b1601438becfff7256627" args="(const Vector2&lt; T &gt; &amp;V, T X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt;T&gt; sf::operator/           </td>
          <td>(</td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator / overload ; divide a vector by a scalar value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>: Vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>: Scalar value</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V / X </dd></dl>

</div>
</div><p>
<a class="anchor" name="29b29d4b0d643cfaa38206695c4518ba"></a><!-- doxytag: member="sf::operator/=" ref="29b29d4b0d643cfaa38206695c4518ba" args="(Vector3&lt; T &gt; &amp;V, T X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector3.htm">Vector3</a>&lt;T&gt;&amp; sf::operator/=           </td>
          <td>(</td>
          <td class="paramtype">Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator /= overload ; divide-assign a vector by a scalar value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>: Vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>: Scalar value</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V / X </dd></dl>

</div>
</div><p>
<a class="anchor" name="7d5a1bbf217894f98676c8cd4c57a8d1"></a><!-- doxytag: member="sf::operator/=" ref="7d5a1bbf217894f98676c8cd4c57a8d1" args="(Vector2&lt; T &gt; &amp;V, T X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2</a>&lt;T&gt;&amp; sf::operator/=           </td>
          <td>(</td>
          <td class="paramtype">Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator /= overload ; divide-assign a vector by a scalar value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>: Vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>: Scalar value</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>V / X </dd></dl>

</div>
</div><p>
<a class="anchor" name="664bd54831f1d70588ae9da837be84f9"></a><!-- doxytag: member="sf::operator&lt;&lt;" ref="664bd54831f1d70588ae9da837be84f9" args="(std::ostream &amp;Stream, const IPAddress &amp;Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SFML_API std::ostream&amp; sf::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>Stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IPAddress &amp;&nbsp;</td>
          <td class="paramname"> <em>Address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator &lt;&lt; overload to print an address to an output stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>: Output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>: Address to print</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Reference to the output stream </dd></dl>

</div>
</div><p>
<a class="anchor" name="2d7edce0db1b576722d9e364c7d08ef9"></a><!-- doxytag: member="sf::operator==" ref="2d7edce0db1b576722d9e364c7d08ef9" args="(const Vector3&lt; T &gt; &amp;V1, const Vector3&lt; T &gt; &amp;V2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sf::operator==           </td>
          <td>(</td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator == overload ; compares the equality of two vectors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>: First vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>: Second vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if V1 is equal to V2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="eb2e9506aa20c13b065592724eafa1d7"></a><!-- doxytag: member="sf::operator==" ref="eb2e9506aa20c13b065592724eafa1d7" args="(const Vector2&lt; T &gt; &amp;V1, const Vector2&lt; T &gt; &amp;V2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sf::operator==           </td>
          <td>(</td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator == overload ; compares the equality of two vectors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>: First vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>: Second vector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if V1 is equal to V2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="cc2f75d5067454f82d05b194ecad3ad1"></a><!-- doxytag: member="sf::operator&gt;&gt;" ref="cc2f75d5067454f82d05b194ecad3ad1" args="(std::istream &amp;Stream, IPAddress &amp;Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SFML_API std::istream&amp; sf::operator&gt;&gt;           </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>Stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IPAddress &amp;&nbsp;</td>
          <td class="paramname"> <em>Address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operator &gt;&gt; overload to extract an address from an input stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>: <a class="el" href="classsf_1_1Input.htm" title="Input handles real-time input from keyboard and mouse.">Input</a> stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>: Address to extract</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Reference to the input stream </dd></dl>

</div>
</div><p>
<a class="anchor" name="bf3b28a7f7637d7babad2756db57e44d"></a><!-- doxytag: member="sf::Sleep" ref="bf3b28a7f7637d7babad2756db57e44d" args="(float Duration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SFML_API sf::Sleep           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>Duration</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make the current thread sleep for a given time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Duration</em>&nbsp;</td><td>: Time to sleep, in seconds </td></tr>
  </table>
</dl>

</div>
</div><p>

        <p id="footer">
            &nbsp;::&nbsp; Copyright &copy; 2007-2008 Laurent Gomila, all rights reserved &nbsp;::&nbsp;
            Documentation generated by <a href="http://www.doxygen.org/" title="doxygen website">doxygen 1.5.2</a> &nbsp;::&nbsp;
        </p>

    </body>
</html>
